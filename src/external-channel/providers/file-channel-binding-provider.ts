import {
  parseExternalChannelProvider,
  type ExternalChannelProvider,
} from "autobyteus-ts/external-channel/provider.js";
import {
  parseExternalChannelTransport,
  type ExternalChannelTransport,
} from "autobyteus-ts/external-channel/channel-transport.js";
import type {
  ChannelBinding,
  ChannelBindingLookup,
  ChannelBindingProviderDefaultLookup,
  ChannelDispatchTarget,
  ChannelSourceRoute,
  UpsertChannelBindingInput,
} from "../domain/models.js";
import type { ChannelBindingProvider } from "./channel-binding-provider.js";
import {
  nextNumericStringId,
  normalizeNullableString,
  normalizeRequiredString,
  parseDate,
  readJsonArrayFile,
  resolvePersistencePath,
  updateJsonArrayFile,
} from "../../persistence/file/store-utils.js";

type ChannelBindingRecord = {
  id: string;
  provider: string;
  transport: string;
  accountId: string;
  peerId: string;
  threadId: string;
  targetType: "AGENT" | "TEAM";
  agentId: string | null;
  teamId: string | null;
  targetNodeName: string | null;
  allowTransportFallback: boolean;
  createdAt: string;
  updatedAt: string;
};

const bindingsFilePath = resolvePersistencePath("external-channel", "bindings.json");

const toThreadStorage = (threadId: string | null): string => normalizeNullableString(threadId) ?? "";
const fromThreadStorage = (threadId: string): string | null => normalizeNullableString(threadId);

const parseTargetType = (value: string): "AGENT" | "TEAM" => {
  if (value === "AGENT" || value === "TEAM") {
    return value;
  }
  throw new Error(`Unsupported channel target type stored in file: ${value}`);
};

const toDomain = (value: ChannelBindingRecord): ChannelBinding => ({
  id: value.id,
  provider: parseExternalChannelProvider(value.provider),
  transport: parseExternalChannelTransport(value.transport),
  accountId: value.accountId,
  peerId: value.peerId,
  threadId: fromThreadStorage(value.threadId),
  targetType: parseTargetType(value.targetType),
  agentId: value.agentId,
  teamId: value.teamId,
  targetNodeName: value.targetNodeName,
  allowTransportFallback: value.allowTransportFallback,
  createdAt: parseDate(value.createdAt),
  updatedAt: parseDate(value.updatedAt),
});

const sortByUpdatedAtDesc = (rows: ChannelBindingRecord[]): ChannelBindingRecord[] =>
  [...rows].sort((a, b) => {
    const updatedDiff = parseDate(b.updatedAt).getTime() - parseDate(a.updatedAt).getTime();
    if (updatedDiff !== 0) {
      return updatedDiff;
    }
    return parseDate(b.createdAt).getTime() - parseDate(a.createdAt).getTime();
  });

export class FileChannelBindingProvider implements ChannelBindingProvider {
  async findBinding(input: ChannelBindingLookup): Promise<ChannelBinding | null> {
    const rows = await readJsonArrayFile<ChannelBindingRecord>(bindingsFilePath);
    const found = rows.find(
      (row) =>
        row.provider === input.provider &&
        row.transport === input.transport &&
        row.accountId === input.accountId &&
        row.peerId === input.peerId &&
        row.threadId === toThreadStorage(input.threadId),
    );
    return found ? toDomain(found) : null;
  }

  async findProviderDefaultBinding(
    input: ChannelBindingProviderDefaultLookup,
  ): Promise<ChannelBinding | null> {
    const rows = await readJsonArrayFile<ChannelBindingRecord>(bindingsFilePath);
    const found = sortByUpdatedAtDesc(rows).find(
      (row) =>
        row.provider === input.provider &&
        row.accountId === input.accountId &&
        row.peerId === input.peerId &&
        row.threadId === toThreadStorage(input.threadId) &&
        row.allowTransportFallback,
    );
    return found ? toDomain(found) : null;
  }

  async findBindingByDispatchTarget(
    target: ChannelDispatchTarget,
  ): Promise<ChannelBinding | null> {
    const rows = await readJsonArrayFile<ChannelBindingRecord>(bindingsFilePath);
    const sorted = sortByUpdatedAtDesc(rows);

    const agentId = normalizeNullableString(target.agentId);
    if (agentId) {
      const byAgent = sorted.find((row) => row.targetType === "AGENT" && row.agentId === agentId);
      if (byAgent) {
        return toDomain(byAgent);
      }
    }

    const teamId = normalizeNullableString(target.teamId);
    if (!teamId) {
      return null;
    }

    const byTeam = sorted.find((row) => row.targetType === "TEAM" && row.teamId === teamId);
    return byTeam ? toDomain(byTeam) : null;
  }

  async isRouteBoundToTarget(
    route: ChannelSourceRoute,
    target: ChannelDispatchTarget,
  ): Promise<boolean> {
    const rows = await readJsonArrayFile<ChannelBindingRecord>(bindingsFilePath);
    const agentId = normalizeNullableString(target.agentId);
    const teamId = normalizeNullableString(target.teamId);

    return rows.some((row) => {
      const routeMatched =
        row.provider === route.provider &&
        row.transport === route.transport &&
        row.accountId === route.accountId &&
        row.peerId === route.peerId &&
        row.threadId === toThreadStorage(route.threadId);
      if (!routeMatched) {
        return false;
      }
      return (
        (agentId && row.targetType === "AGENT" && row.agentId === agentId) ||
        (teamId && row.targetType === "TEAM" && row.teamId === teamId)
      );
    });
  }

  async listBindings(): Promise<ChannelBinding[]> {
    const rows = await readJsonArrayFile<ChannelBindingRecord>(bindingsFilePath);
    return sortByUpdatedAtDesc(rows).map((row) => toDomain(row));
  }

  async upsertBinding(input: UpsertChannelBindingInput): Promise<ChannelBinding> {
    const now = new Date().toISOString();
    let saved: ChannelBindingRecord | null = null;

    await updateJsonArrayFile<ChannelBindingRecord>(bindingsFilePath, (rows) => {
      const index = rows.findIndex(
        (row) =>
          row.provider === input.provider &&
          row.transport === input.transport &&
          row.accountId === input.accountId &&
          row.peerId === input.peerId &&
          row.threadId === toThreadStorage(input.threadId),
      );

      if (index >= 0) {
        const current = rows[index] as ChannelBindingRecord;
        const savedRecord: ChannelBindingRecord = {
          ...current,
          targetType: input.targetType,
          agentId: normalizeNullableString(input.agentId ?? null),
          teamId: normalizeNullableString(input.teamId ?? null),
          targetNodeName: normalizeNullableString(input.targetNodeName ?? null),
          allowTransportFallback: input.allowTransportFallback ?? false,
          updatedAt: now,
        };
        const next = [...rows];
        saved = savedRecord;
        next[index] = savedRecord;
        return next;
      }

      const savedRecord: ChannelBindingRecord = {
        id: nextNumericStringId(rows),
        provider: input.provider,
        transport: input.transport,
        accountId: input.accountId,
        peerId: input.peerId,
        threadId: toThreadStorage(input.threadId),
        targetType: input.targetType,
        agentId: normalizeNullableString(input.agentId ?? null),
        teamId: normalizeNullableString(input.teamId ?? null),
        targetNodeName: normalizeNullableString(input.targetNodeName ?? null),
        allowTransportFallback: input.allowTransportFallback ?? false,
        createdAt: now,
        updatedAt: now,
      };
      saved = savedRecord;
      return [...rows, savedRecord];
    });

    if (!saved) {
      throw new Error("Failed to upsert channel binding record.");
    }
    return toDomain(saved);
  }

  async upsertBindingAgentId(bindingId: string, agentId: string): Promise<ChannelBinding> {
    const normalizedId = normalizeRequiredString(bindingId, "bindingId");
    const normalizedAgentId = normalizeRequiredString(agentId, "agentId");
    const now = new Date().toISOString();
    let saved: ChannelBindingRecord | null = null;

    await updateJsonArrayFile<ChannelBindingRecord>(bindingsFilePath, (rows) => {
      const index = rows.findIndex((row) => row.id === normalizedId);
      if (index < 0) {
        throw new Error("Binding not found");
      }
      const current = rows[index] as ChannelBindingRecord;
      const savedRecord: ChannelBindingRecord = {
        ...current,
        targetType: "AGENT",
        agentId: normalizedAgentId,
        updatedAt: now,
      };
      const next = [...rows];
      saved = savedRecord;
      next[index] = savedRecord;
      return next;
    });

    if (!saved) {
      throw new Error("Failed to update channel binding agent id.");
    }
    return toDomain(saved);
  }

  async deleteBinding(bindingId: string): Promise<boolean> {
    const normalizedId = normalizeRequiredString(bindingId, "bindingId");
    let removed = false;

    await updateJsonArrayFile<ChannelBindingRecord>(bindingsFilePath, (rows) => {
      const next = rows.filter((row) => row.id !== normalizedId);
      removed = next.length !== rows.length;
      return next;
    });

    return removed;
  }
}

export type { ExternalChannelProvider, ExternalChannelTransport };
